"""
Robust Authentication Service

Handles user authentication with proper token management and validation.
"""

import uuid as uuid_lib
import os
from datetime import datetime, timedelta
from typing import Optional, Dict, Tuple
from .LoggerService import LoggerService
from .JWTService import JWTService
from .ConfigService import ConfigService


class AuthService:
    """
    Authentication service for user login and session management
    
    Supports:
    - Offline mode (guest login)
    - Token-based authentication
    - Token refresh
    - Session validation
    """
    
    OFFLINE_MODE = "offline"
    ONLINE_MODE = "online"
    
    @classmethod
    def generate_offline_session(cls, username: str, user_uuid: str) -> Dict:
        """
        Generate offline/guest session tokens with proper EdDSA signing
        
        Args:
            username: Player username
            user_uuid: Unique identifier for the player
        
        Returns:
            Dictionary with tokens
        """
        try:
            LoggerService.info(f"[AuthService] Generating offline session for: {username}")
            
            # Use JWTService to create properly signed EdDSA tokens
            tokens = JWTService.create_hytale_tokens(username, user_uuid)
            
            LoggerService.info(f"[AuthService] Generated signed tokens for {username}")
            
            return {
                "IdentityToken": tokens["IdentityToken"],
                "SessionToken": tokens["SessionToken"],
                "mode": cls.OFFLINE_MODE,
                "username": username,
                "uuid": user_uuid,
                "expires_at": (datetime.utcnow() + timedelta(days=30)).isoformat()
            }
        except Exception as e:
            LoggerService.error(f"[AuthService] Failed to generate offline session: {e}")
            raise
    
    @classmethod
    def generate_tokens(cls, user_uuid: str, username: str, avatar_url: Optional[str] = None) -> Dict:
        """
        Generate JWT tokens for user
        
        Args:
            user_uuid: User's UUID
            username: Username
            avatar_url: Optional avatar URL
        
        Returns:
            Dictionary with access and refresh tokens
        """
        try:
            LoggerService.info(f"[AuthService] Generating tokens for: {username} ({user_uuid})")
            
            # Create token pair for launcher communication
            tokens = JWTService.create_token_pair(username, user_uuid)
            
            # Try to fetch tokens from remote auth server first (e.g. Sanasol)
            # This is required because the client is patched to check sanasol.ws keys
            hytale_tokens = None
            try:
                domain = ConfigService.get_auth_domain() or "sanasol.ws"
                auth_url = f"https://sessions.{domain}"
                
                # Use new unified method that handles fallback internally if needed
                # But here we want to catch if it failed completely
                hytale_tokens = JWTService.create_hytale_tokens(username, user_uuid)
                
            except Exception as e:
                LoggerService.warning(f"[AuthService] Auth attempt failed: {e}")

            if not hytale_tokens:
                raise Exception("Failed to generate or fetch Hytale tokens.")
            
            tokens.update({
                "IdentityToken": hytale_tokens["IdentityToken"],
                "SessionToken": hytale_tokens["SessionToken"],
                "mode": cls.ONLINE_MODE,
                "username": username,
                "uuid": user_uuid
            })
            
            return tokens
        except Exception as e:
            LoggerService.error(f"[AuthService] Failed to generate tokens: {e}")
            raise
    
    @classmethod
    def verify_session(cls, identity_token: str, session_token: str) -> Tuple[bool, Optional[Dict]]:
        """
        Verify a session using both tokens
        """
        try:
            if not identity_token or not session_token:
                LoggerService.warning("[AuthService] Missing tokens for verification")
                return False, None
            
            # In a real scenario, we would verify the EdDSA signature here
            # For now, we trust tokens generated by our own JWTService
            return True, {"identity_token": identity_token, "session_token": session_token}
            
        except Exception as e:
            LoggerService.error(f"[AuthService] Verification error: {e}")
            return False, None
    
    @classmethod
    def refresh_session(cls, refresh_token: str) -> Optional[Dict]:
        """
        Refresh a session using refresh token
        """
        try:
            LoggerService.info("[AuthService] Refreshing session")
            new_access_token = JWTService.refresh_access_token(refresh_token)
            
            if new_access_token:
                payload = JWTService.verify_token(refresh_token)
                username = payload.get("username")
                uuid = payload.get("uuid") or payload.get("user_id")
                
                # Regenerate Hytale tokens as well
                # Try remote first, fail if impossible (for online mode)
                hytale_tokens = None
                try:
                    domain = ConfigService.get_auth_domain() or "sanasol.ws"
                    auth_url = f"https://sessions.{domain}"
                    hytale_tokens = JWTService.fetch_remote_tokens(username, uuid, auth_url)
                except Exception as e:
                    LoggerService.warning(f"[AuthService] Remote refresh failed: {e}")

                if not hytale_tokens:
                     # If we can't refresh remote tokens, the session is effectively dead for online play
                     LoggerService.error("[AuthService] Failed to refresh remote Hytale tokens.")
                     return None

                return {
                    "access_token": new_access_token,
                    "token_type": "bearer",
                    "username": username,
                    "uuid": uuid,
                    "IdentityToken": hytale_tokens["IdentityToken"],
                    "SessionToken": hytale_tokens["SessionToken"]
                }
            return None
        except Exception as e:
            LoggerService.error(f"[AuthService] Session refresh failed: {e}")
            return None
    
    @classmethod
    def logout(cls, username: str) -> bool:
        """
        Logout user
        """
        try:
            LoggerService.info(f"[AuthService] User logged out: {username}")
            return True
        except Exception as e:
            LoggerService.error(f"[AuthService] Logout failed: {e}")
            return False
